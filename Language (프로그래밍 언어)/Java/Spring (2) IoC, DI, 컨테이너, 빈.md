# Spring - IoC, DI, 컨테이너, 빈

---

### IoC (Inversion of Control) 제어의 역전 🔥🔥🔥

> Don't call us, we will call you.
>
> *- 헐리우드 원칙(Hollywood Principle)*

- **프레임워크 없이 개발할 때에는 객체의 생성, 설정, 초기화, 메소드 호출, 소멸(이하 객체의 생명주기)을 프로그래머가 직접 관리한다.** 또한 전통적인 프로그래밍에서는 외부 라이브러리를 사용할 때, 개발자가 직접 외부 라이브러리를 호출하는 형태로 이용한다. 자연스러운 일이다.
- 하지만, 프레임워크를 사용하면 객체의 생명 주기를 모두 프레임워크에 위임할 수 있다. 즉, **외부 라이브러리가 프로그래머가 작성한 코드를 호출하고, 흐름을 제어한다.** 
- 제어의 역전에서는 오브젝트 스스로가 사용할 오브젝트를 결정하지도, 생성하지 않는다. 원칙의 이름 그대로 제어에 대한 권한이 개발자에서 외부 환경으로 역전되는 것이다. **메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라, 외부에서 결정되는 것**
- **어플리케이션의 제어 책임이 프로그래머에서 프레임워크로 위임되므로, 개발자는 핵심 비즈니스 로직에 더 집중할 수 있다는 장점이 있다.**

---

### DI (Dependency Injection) 의존관계 주입 🔥🔥🔥

- DI는 IoC 원칙을 실현하기 위한 여러 디자인패턴 중 하나이다. 
- **스프링이 다른 프레임워크와 차별화되어 제공하는 의존 관계 주입 기능**으로, **객체를 직접 생성하는 게 아니라 외부에서 생성한 후 주입 시켜주는 방식**이다.
- IoC와 DI 모두 **객체간의 결합을 느슨하게 만들어 유연하고 확장성이 뛰어난 코드를 작성**하기 위한 패턴이다.

---

### IoC 컨테이너, DI 컨테이너 🔥🔥🔥

- AppConfig 처럼 **객체를 생성하고 관리하면서 의존관계를 연결해 주는 것**을 IoC 컨테이너 또는 DI 컨테이너라고 한다.
- 의존관계 주입에 초점을 맞추어 최근에는 주로 **DI 컨테이너**라고 한다.
- 또는 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.
- 컨테이너란 당신이 작성한 코드의 처리과정을 위임받은 독립적인 존재라고 생각하면 된다. 컨테이너는 적절한 설정만 되어있다면 누구의 도움 없이도 프로그래머가 작성한 코드를 스스로 참조한 뒤 알아서 객체의 생성과 소멸을 컨트롤해준다.
- 스프링 컨테이너는 스프링 프레임워크의 핵심부에 위치하며, 종속객체 주입을 이용하여 애플리케이션을 구성하는 컴포넌트들을 관리한다. 이때 스프링 컨테이너에서 생성되는 객체를 **Bean**이라고 한다.

---

### 정적인 클래스 의존 관계

- 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 

- 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다. 

- 클래스 다이어그램을 보면 OrderServiceImpl 은 MemberRepository , DiscountPolicy 에 의존한다는 것을 알 수 있다. 그런데 이러한 클래스 의존관계 만으로는 실제 어떤 객체가 OrderServiceImpl 에 주입 될지 알 수 없다.

- 클래스 다이어그램

  ![클래스다이어그램](https://user-images.githubusercontent.com/122634701/215305187-dfcce987-be48-48b8-9343-fd7643fdc94e.png)

### 동적인 객체 인스턴스 의존 관계
- 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다.

- 객체 다이어그램

  ![객체다이어그램](https://user-images.githubusercontent.com/122634701/215305238-32c457d3-32f6-417a-ad5d-e6de72fc725d.png)

  - 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 의존관계 주입이라 한다.
  - 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.
  - 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
  - **의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.**

---

### 스프링 컨테이너, 스프링 빈 🔥🔥🔥

- `ApplicationContext`를 스프링 컨테이너라고 한다.
- 이전에는 개발자가 AppConfig를 사용해서 직접 객체를 생성하고 DI했지만, 이제부터는 스프링 컨테이너로 한다.
- 스프링 컨테이너는 `@Configuration`이 붙은 AppConfig 를 설정(구성) 정보로 사용한다. 여기서 @Bean
  이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이렇게 스프링 컨테이너에
  등록된 객체를 스프링 빈이라 한다.
- `ApplicationContext`는 인터페이스다. 
-  XML을 기반으로 만들 수 있고, **애노테이션 기반의 자바 설정 클래스**(`@Configuration`이 붙은 AppConfig)로 만들 수 있다.
- `AnnotationConfigApplicationContext`는 `ApplicationContext`의 구현체다.
- 스프링 컨테이너는 다양한 형식의 설정 정보를 받아드릴 수 있게 유연하게 설계되어 있다.
  자바 코드(애노테이션 기반), XML, Groovy 등등
- 아직 많은 레거시 프로젝트 들이 XML로 되어 있고, 또 XML을 사용하면 컴파일 없이 빈 설정 정보를 변경할 수 있는 장점도 있으므로 한번쯤 배워두는 것도 괜찮다.
- 스프링은 어떻게 이런 다양한 설정 형식을 지원하는 것일까? 그 중심에는 **BeanDefinition** 이라는
  추상화가 있다.

---

### BeanDefinition (스프링 빈 설정 메타 정보)

- 쉽게 이야기해서 **역할과 구현을 개념적으로 나눈 것**이다!

  👉 XML을 읽어서 BeanDefinition을 만들면 된다.

  👉 자바 코드를 읽어서 BeanDefinition을 만들면 된다.

  ✅ 스프링 컨테이너는 자바 코드인지, XML인지 몰라도 된다. 오직 BeanDefinition만 알면 된다.

- @Bean , <bean> 당 각각 하나씩 메타 정보가 생성된다.

- 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.

  ![image](https://user-images.githubusercontent.com/122634701/215320455-8503623d-f765-4bc1-87ed-d557af28ace2.png)

- AnnotationConfigApplicationContext 는 AnnotatedBeanDefinitionReader 를 사용해서 AppConfig.class 를 읽고 BeanDefinition 을 생성한다.

- GenericXmlApplicationContext 는 XmlBeanDefinitionReader 를 사용해서 appConfig.xml 설정 정보를 읽고 BeanDefinition 을 생성한다.

- 새로운 형식의 설정 정보가 추가되면, XxxBeanDefinitionReader를 만들어서 BeanDefinition 을 생성하면 된다.

- BeanDefinition 속성

  > - BeanClassName: 생성할 빈의 클래스 명(자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)
  > - factoryBeanName: 팩토리 역할의 빈을 사용할 경우 이름, 예) appConfig
  > - factoryMethodName: 빈을 생성할 팩토리 메서드 지정, 예) memberService
  > - Scope: 싱글톤(기본값)
  > - lazyInit: 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때 까지 최대한
  >   생성을 지연처리 하는지 여부
  > - InitMethodName: 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명
  > - DestroyMethodName: 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명
  > - Constructor arguments, Properties: 의존관계 주입에서 사용한다. (자바 설정 처럼 팩토리 역할의
  >   빈을 사용하면 없음)

- 정리

  > - BeanDefinition을 직접 생성해서 스프링 컨테이너에 등록할 수 도 있다. 하지만 실무에서
  >   BeanDefinition을 직접 정의하거나 사용할 일은 거의 없다. 어려우면 그냥 넘어가면 된다^^!
  > - BeanDefinition에 대해서는 너무 깊이있게 이해하기 보다는, 스프링이 다양한 형태의 설정 정보를
  >   BeanDefinition으로 추상화해서 사용하는 것 정도만 이해하면 된다.
  > - 가끔 스프링 코드나 스프링 관련 오픈 소스의 코드를 볼 때, BeanDefinition 이라는 것이 보일 때가 있다.
  >   이때 이러한 메커니즘을 떠올리면 된다.

---

### BeanFactory와 ApplicationContext

| ![image](https://user-images.githubusercontent.com/122634701/215316723-120d1a38-2a54-4d27-bd4d-77eb5ab69a6a.png) | ![image](https://user-images.githubusercontent.com/122634701/215316760-c8dc549b-63f1-4d69-8fbb-3cf8353657f4.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

- **BeanFactory**

  > - 스프링 컨테이너의 최상위 인터페이스다.
  > - **스프링 빈을 관리하고 조회하는 역할을 담당**한다.
  > - **getBean() 을 제공**한다.

- **ApplicationContext**

  > - BeanFactory 기능을 모두 상속받아서 제공한다.
  >
  > - 빈을 관리하고 검색하는 기능을 BeanFactory가 제공해주는데, 그러면 둘의 차이가 뭘까?
  >
  > - 애플리케이션을 개발할 때는 빈을 관리하고 조회하는 기능은 물론이고, 수 많은 부가기능이 필요하다.
  >
  > - **ApplicatonContext가 제공하는 부가기능** 🔥🔥🔥
  >
  >   > - 메시지소스를 활용한 국제화 기능
  >   >   👉 예를 들어서 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력
  >   > - 환경변수
  >   >   👉 로컬, 개발, 운영등을 구분해서 처리
  >   > - 애플리케이션 이벤트
  >   >   👉 이벤트를 발행하고 구독하는 모델을 편리하게 지원
  >   > - 편리한 리소스 조회
  >   >   👉 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

- 정리

  > - ApplicationContext는 BeanFactory의 기능을 상속받는다.
  > - ApplicationContext는 빈 관리기능 + 편리한 부가 기능을 제공한다.
  > - BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용한다.
  > - BeanFactory나 ApplicationContext를 스프링 컨테이너라 한다.

---



