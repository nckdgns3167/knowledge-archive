# Spring 메모장

---

### 로드  존슨

- 스프링의 아이디어와 기반 코드를 만듬.
- EJB(Enterprise Java Beans) 문제점 지적
- BeanFactory, ApplicationContext, POJO, Inversion of Control(제어의 역전), Dependency Injection(의존성 주입)
- 유겐 휠러(스프링 핵심 코드 개발), 얀 카로프가 먼저 오픈소스 프로젝트를 하자고 로드 존슨에게 제안.

---

### 스프링 생태계

- 스프링 프레임워크 
- 스프링 부트         
- 스프링 데이터
- 스프링 세션       
- 스프링 시큐리티     
- 스프링 REST Docs
- 스프링 배치      
- 스프링 클라우드   

---

### 스프링 프레임워크

- 핵심 기술: **DI 컨테이너, AOP**, 이벤트, 기타
- 웹 기술: **스프링 MVC**, 스프링 WebFlux
- 데이터 접근 기술: 트랜잭션, **JDBC**, ORM 지원, XMl 지원
- 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: **코틀린**, 그루비
- 최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용

---

### 스프링 부트

- Tomcat과 같은 별도의 웹서버를 설치할 필요 없이 내장되어 있다. 👉 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성.
- 손쉬운 빌드 구성을 위한 **starter 종속성** 제공 👉 연관된 라이브러리 알아서 잘 한번에 처리
- 스프링과 **3rd party 라이브러리 자동 구성** 👉 버전 고민 X, 라이브러리끼리의 버전 궁합 알아서 체크
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공 👉 모니터링 쉽게
- 관례에 의한 간결한 설정

---

### 스프링? 다음과 같이 문맥에 따라 다르게 사용된다.

- **스프링 DI 컨테이너 기술**
- 스프링 프레임워크
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

---

### 스프링을 왜 만든거야 ???

- 핵심을 알고 공부해야지, 사용법만 알면 안 된다...
- 웹 애플리케이션 만들고, DB 접근 편리하게 해주기 때문에? 전자정부 프레임워크? 웹 서버 자동 구동? 클라우드? 마이크로 서비스? 아니다! 이런 것들은 다 결과물일 뿐이다...
- 그럼 핵심은 무엇인가? 핵심은 바로 **스프링은 Java 기반의 프레임워크라는 것**이다. Java라는 언어의 가장 큰 특징은 **객체 지향 언어**이다. 이 핵심 특징을 그대로 살려내는 게 바로 스프링인 것이다. 즉 **스프링이란 좋은 객체 지향 애플리케이션을 만들 수 있도록 도와주는 프레임워크이다.**

---

### 좋은 객체 지향 프로그래밍이란 어떤 것일까?

- 먼저 객체 지향의 특징으로...  **추상화, 캡슐화, 상속, 다형성** 
- 레고 블럭 조립하듯이...키보드, 마우스 갈아 끼우듯이...컴퓨터 부품 갈아 끼우듯이...컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있게 하는 것. 👉 **다형성 (polymorphism)**
- **역할과 구현을 분리 (중요)** 🔥🔥🔥
  - 세상이 단순해지고, 유연해지며 변경이 편리해진다.
  - 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
  - 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
  - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
  - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
- Java에서 위와 같은 컨셉(다형성)을 이루기 위해 객체를 설계할 때, **인터페이스(역할)과 그 인터페이스를 구현한 클래스(구현, 그 역할을 수행하는 구현체)**가 있다. 👉 **역할과 구현을 명확히 분리**...
- **Java의 다형성**
  - **오버라이딩**(부모 메소드 재정의 - 틀은 같고 내용만 변경함. 접근 지정자만 부모보다 넓거나 유지...), **오버로딩**(동일한 이름의 메소드들 여러개 정의, 매개변수 타입과 개수만 다르게...), **상속받은 객체의 참조변수 형변환(Casting)**
  - 오버라이딩된 메서드가 실행
  - 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질?
  - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
  - 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야 함.
  - 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.
- **정리 (중요)** 🔥🔥🔥
  - 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있다.
  - 유연하고, 변경이 용이
  - 확장 가능한 설계
  - 클라이언트에 영향을 주지 않는 변경 가능
  - **인터페이스를 안❗정❗적❗으❗로❗잘 설계하는 것이 중요 **👉 잘못 설계되거나 변경되면 영향이 큼.

---

### 스프링과 객체 지향

- **객체 지향의 꽃은 다형성**... 가장 중요하다.
- **스프링이 이 다형성을 극대화 이용할 수 있게 도와준다.**
- 스프링에서 이야기하는 **IoC, DI는 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록** 한다.
- **스프링을 사용하면 구현을 편리하게 변경할 수 있다...**

---

### S.O.L.I.D  솔리드 원칙

- 클린 코드로 유명한 로버트 마틴이 좋은 객체 지향 설계 5가지 원칙을 정리

- **`SRP`**: 단일 책임 원칙 ( Single Reponsibility Principle )
> - 한 클래스는 하나의 책임만 가져야 한다.
>
> - 어떠한 변경이 일어났을 때 파급 효과가 적으면 이 원칙을 잘 따른 것. (UI 변경, 객체의 생성과 사용을 분리)
>
> - 책임의 크기를 적절하게 조절하는 게 객체 지향 설계의 묘미.

- **`OCP`**: **개방 폐쇄 원칙 ( Open Closed Principle ) 🔥🔥🔥**

> - 무슨 원칙인지 처음 들어보면 말도 안되는 원칙이다. 
> - 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다...는 것인데, 확장을 하려면 당연히 변경이 필수이지 않은가? 🤔
> - **다형성**을 활용한다는 얘기인 거 같은데...
> - 아직까지 이해가 안된다. 아래처럼 어떤 인터페이스를 구현했던 기존 클래스를 두고 다르게 동작하는 새로운 클래스를 하나 만들어서 갈아 끼우는 예제를 떠올려보면 확장을 하고있기는 한데, 기존 코드를 주석처리하고 새로운 것으로 ''변경''하고 있지 않은가? 분명 다형성을 활용했지만 OCP 원칙을 따르지 않고 있다.
> - ![image](https://user-images.githubusercontent.com/122634701/215139846-d48ce2cd-ae92-4228-8bf2-3222ef21f97c.png)
> - 구현 객체를 변경하려면 위처럼 클라이언트 코드 변경이 불가피한 것처럼 여겨진다. 그런데 그게 가능하기 때문에 원칙으로 있을 것이다. 과연 어떻게 이 문제를 해결할까?
> - 별도의 무언가가 필요하다. 객체를 생성하고, 연관 관계를 맺어주는 무언가가...
> - **위 사례는 OCP와 DIP에 위반한다.**

- **`LSP`**: 리스코프 치환 원칙 ( Liskov Substitution Principle )

> - 개방 폐쇄 원칙을 받쳐 주는 **다형성**에 관한 원칙을 제공한다...
> - **상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.**
> - 리스코프 치환 원칙이 제대로 지켜지지 않으면 다형성에 기반한 개방 폐쇄 원칙 역시 지켜지지 않기 때문에, 리스코프 치환 원칙을 지키는 것은 매우 중요하다.
> - 정사각형, 직사각형 예제 
> - **사용자에게 기능 명세를 제공하고, 그 명세에 따라 기능을 구현할 것을 약속한다.**

- **`ISP`**: 인터페이스 분리 원칙 ( Interface Segregation Principle )

> - **인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.** 
>
>   **즉, 클라이언트는 자신이 사용하는 메서드에만 의존해야 한다.**
>
> - 인터페이스가 명확해지고, 대체 가능성이 높아진다.

- **`DIP`**: **의존 관계 역전 원칙 ( Dependency Inversion Principle ) 🔥🔥🔥**

> - **의존성 주입**은... 프로그래머는 **"추상화에 의존해야지, 구체화에 의존하면 안된다."**라는 이 원칙을 따르는 것. 👉 **구현 클래스말고 인터페이스에 의존하라는 말 = 역할에 의존해야 한다는 말**
> - 구현쪽에서도 클라이언트가 인터페이스 쪽에 의존해야 구현체를 유연하게 변경할 수 있다.

- **정리** 🔥🔥🔥

> - SOLID 원칙은 변화에 유연하게 대처할 수 있게 해주는 설계 원칙이다.
>
> - **단일 책임 원칙**과 **인터페이스 분리 원칙**은 객체가 커지지 않도록 막아준다. 객체가 많은 기능을 가지게 되면, 객체가 가진 기능의 변경 여파가 그 객체의 다른 기능까지 번지게 되고 이는 다시 다른 기능을 사용하는 클라이언트에게까지 영향을 준다.
>
>   **객체가 단일 책임을 갖게 하고 클라이언트마다 다른 인터페이스를 사용하게 함으로써, 한 기능의 변경이 다른 곳까지 미치는 영향을 최소화할 수 있고, 이는 결국 기능 변경을 보다 쉽게 할 수 있도록 만들어 준다.**
>
> - **리스코프 치환 원칙**과 **의존 역전 원칙**은 **개방 폐쇄 원칙**을 지원한다.
>
>   **개방 폐쇄 원칙은 변화되는 부분을 추상화하고 다형성을 이용함으로써 기능 확장을 하면서도 기존 코드를 수정하지 않도록 만들어 준다.**
>
>   여기서, **변화되는 부분을 추상화**할 수 있도록 도와주는 원칙이 바로 **의존 역전 원칙**이고, **다형성**을 도와주는 원칙이 **리스코프 치환 원칙**인 것이다.

> - 객체 지향의 핵심은 다형성인데, 우리가 그동안 알던(Spring을 알기 전) 다형성이라는 것만으로는 위 원칙을 온전히 지킬 수 없다. 쉽게 부품을 갈아 끼울 수 없고, 구현 객체를 변경할 때 클라이언트 코드도 변경해야한다...**즉 다형성 만으로 OCP, DIP를 지킬 수 없다.**
> - 뭔가가 필요한다...💦 👉 이 뭔가를 알기위해 지금 공부를 하고 있는 것...스프링 메모장이니까 당연히 그걸 가능케 하는 게 스프링일테지...

---

### 아! 그래서 스프링을 쓰는구나!

- 다형성 + OCP, DIP를 가능하게 스프링은 **DI 컨테이너를 제공**한다.
- 이로써 클라이언트 쪽 코드 변경이 일어나지 않는다.

---

### 실무 고민

- 되도록이면 인터페이스를 다 설계해두고 하는 게 좋다고 했는데, 그 또한 추상화하는 비용이 발생하는 것이고 기능을 확장할 가능성이 없는 것이라면 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.

---

### IoC (Inversion of Control) 제어의 역전

> Don't call us, we will call you.
>
> *- 헐리우드 원칙(Hollywood Principle)*

- **프레임워크 없이 개발할 때에는 객체의 생성, 설정, 초기화, 메소드 호출, 소멸(이하 객체의 생명주기)을 프로그래머가 직접 관리한다.** 또한 전통적인 프로그래밍에서는 외부 라이브러리를 사용할 때, 개발자가 직접 외부 라이브러리를 호출하는 형태로 이용한다. 자연스러운 일이다.
- 하지만, 프레임워크를 사용하면 객체의 생명 주기를 모두 프레임워크에 위임할 수 있다. 즉, **외부 라이브러리가 프로그래머가 작성한 코드를 호출하고, 흐름을 제어한다.** 
- 제어의 역전에서는 오브젝트 스스로가 사용할 오브젝트를 결정하지도, 생성하지 않는다. 원칙의 이름 그대로 제어에 대한 권한이 개발자에서 외부 환경으로 역전되는 것이다. **메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라, 외부에서 결정되는 것**
- **어플리케이션의 제어 책임이 프로그래머에서 프레임워크로 위임되므로, 개발자는 핵심 비즈니스 로직에 더 집중할 수 있다는 장점이 있다.**

---

### DI (Dependency Injection) 의존관계 주입

- DI는 IoC 원칙을 실현하기 위한 여러 디자인패턴 중 하나이다. 
- **스프링이 다른 프레임워크와 차별화되어 제공하는 의존 관계 주입 기능**으로, **객체를 직접 생성하는 게 아니라 외부에서 생성한 후 주입 시켜주는 방식**이다.
- IoC와 DI 모두 **객체간의 결합을 느슨하게 만들어 유연하고 확장성이 뛰어난 코드를 작성**하기 위한 패턴이다.

---

### IoC 컨테이너, DI 컨테이너

- AppConfig 처럼 **객체를 생성하고 관리하면서 의존관계를 연결해 주는 것**을 IoC 컨테이너 또는 DI 컨테이너라고 한다.
- 의존관계 주입에 초점을 맞추어 최근에는 주로 **DI 컨테이너**라고 한다.
- 또는 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.

---

### 정적인 클래스 의존관계

- 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 

- 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다. 

- 클래스 다이어그램을 보면 OrderServiceImpl 은 MemberRepository , DiscountPolicy 에 의존한다는 것을 알 수 있다. 그런데 이러한 클래스 의존관계 만으로는 실제 어떤 객체가 OrderServiceImpl 에 주입 될지 알 수 없다.

- 클래스 다이어그램

  ![클래스다이어그램](https://user-images.githubusercontent.com/122634701/215305187-dfcce987-be48-48b8-9343-fd7643fdc94e.png)

### 동적인 객체 인스턴스 의존 관계
- 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다.

- 객체 다이어그램

  ![객체다이어그램](https://user-images.githubusercontent.com/122634701/215305238-32c457d3-32f6-417a-ad5d-e6de72fc725d.png)

  - 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 의존관계 주입이라 한다.
  - 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.
  - 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
  - **의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.**

---







